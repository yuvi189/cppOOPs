/*
ğŸ­.ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ ğ—¢ğ˜ƒğ—²ğ—¿ğ—¹ğ—¼ğ—®ğ—±ğ—¶ğ—»ğ—´ ğ—¶ğ˜€ ğ˜ğ—µğ—² ğ—½ğ—¿ğ—¼ğ—°ğ—²ğ˜€ğ˜€ ğ—¼ğ—³ ğ—´ğ—¶ğ˜ƒğ—¶ğ—»ğ—´ ğ—®ğ—±ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—ºğ—²ğ—®ğ—»ğ—¶ğ—»ğ—´ ğ˜ğ—¼ ğ—®ğ—» ğ—®ğ—¹ğ—¿ğ—²ğ—®ğ—±ğ˜† ğ—²ğ˜…ğ—¶ğ˜€ğ˜ğ—¶ğ—»ğ—´ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿.
ğ—§ğ—µğ—² ğ—¼ğ—¿ğ—¶ğ—´ğ—¶ğ—»ğ—®ğ—¹ ğ—ºğ—²ğ—®ğ—»ğ—¶ğ—»ğ—´ ğ—¼ğ—³ ğ˜ğ—µğ—² ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ ğ˜„ğ—¶ğ—¹ğ—¹ ğ—¿ğ—²ğ—ºğ—®ğ—¶ğ—» ğ—®ğ˜€ ğ—¶ğ˜ ğ—¶ğ˜€ ğ—¯ğ˜‚ğ˜ ğ˜„ğ—²'ğ—¹ğ—¹ ğ—¯ğ—² ğ—®ğ—¯ğ—¹ğ—² ğ˜ğ—¼ 
ğ—½ğ—²ğ—¿ğ—³ğ—¼ğ—¿ğ—º ğ˜€ğ—¼ğ—ºğ—² ğ—®ğ—±ğ—±ğ—¶ğ˜ğ—¶ğ—¼ğ—»ğ—®ğ—¹ ğ—³ğ˜‚ğ—»ğ—°ğ˜ğ—¶ğ—¼ğ—»ğ˜€ ğ˜‚ğ˜€ğ—¶ğ—»ğ—´ ğ˜ğ—µğ—² ğ˜€ğ—®ğ—ºğ—² ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ ğ—¯ğ˜† ğ—¼ğ˜ƒğ—²ğ—¿ğ—¹ğ—¼ğ—®ğ—±ğ—¶ğ—»ğ—´ ğ—¶ğ˜.

ğŸ®.ğ—ªğ—² ğ—°ğ—®ğ—» ğ—½ğ—²ğ—¿ğ—³ğ—¼ğ—¿ğ—º ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ ğ—¼ğ˜ƒğ—²ğ—¿ğ—¹ğ—¼ğ—®ğ—±ğ—¶ğ—»ğ—´ ğ—¯ğ˜† ğ—°ğ—¿ğ—²ğ—®ğ˜ğ—¶ğ—»ğ—´ ğ—® ğ—ºğ—²ğ—ºğ—¯ğ—²ğ—¿ ğ—¼ğ—¿ ğ—»ğ—¼ğ—»-ğ—ºğ—²ğ—ºğ—¯ğ—²ğ—¿(ğ—³ğ—¿ğ—¶ğ—²ğ—»ğ—±) ğ—³ğ˜‚ğ—»ğ—°ğ˜ğ—¶ğ—¼ğ—».

Syntax:-
return_type operator operator_symbol(parameters)
{

}

eg:-
If we want to overload the ++operator uisng a member function then we can do so as follows:-

return_type operator++(parameters)
{

}

AND

If we want to overload the ++operator using a function which is only declared inside the class but defined outside the class,
it can be done as follows:-

return_type class_name::operator++(parameters)
{

}

ğŸ¯.ğ—§ğ—µğ—²ğ—¿ğ—² ğ—®ğ—¿ğ—² ğ˜€ğ—¼ğ—ºğ—² ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ğ˜€ ğ˜„ğ—µğ—¶ğ—°ğ—µ ğ—°ğ—®ğ—»ğ—»ğ—¼ğ˜ ğ—¯ğ—² ğ—¼ğ˜ƒğ—²ğ—¿ğ—¹ğ—¼ğ—®ğ—±ğ—²ğ—±:-
  (ğ—¶)ğ—§ğ—²ğ—¿ğ—»ğ—®ğ—¿ğ˜† ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿(?:)
  (ğ—¶ğ—¶)ğ——ğ—¼ğ˜ ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿(.)
  (ğ—¶ğ—¶ğ—¶)ğ——ğ—¼ğ˜ ğ—¦ğ˜ğ—®ğ—¿ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿(.*)
  (ğ—¶ğ˜ƒ)ğ—¦ğ—°ğ—¼ğ—½ğ—² ğ—¥ğ—²ğ˜€ğ—¼ğ—¹ğ˜‚ğ˜ğ—¶ğ—¼ğ—» ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿(::)
  (ğ˜ƒ)ğ—¦ğ—¶ğ˜‡ğ—²ğ—¢ğ—³ ğ—¢ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿(ğ˜€ğ—¶ğ˜‡ğ—²ğ—¼ğ—³())

ğŸ°.ğ—§ğ—µğ—²ğ—¿ğ—² ğ—®ğ—¿ğ—² ğ˜€ğ—¼ğ—ºğ—² ğ˜€ğ—½ğ—²ğ—°ğ—¶ğ—®ğ—¹ ğ—¼ğ—½ğ—²ğ—¿ğ—®ğ˜ğ—¼ğ—¿ğ˜€ ğ˜„ğ—µğ—¶ğ—°ğ—µ ğ—°ğ—®ğ—»ğ—»ğ—¼ğ˜ ğ—¯ğ—² ğ—¼ğ˜ƒğ—²ğ—¿ğ—¹ğ—¼ğ—®ğ—±ğ—²ğ—± ğ˜‚ğ˜€ğ—¶ğ—»ğ—´ ğ—³ğ—¿ğ—¶ğ—²ğ—»ğ—± ğ—³ğ˜‚ğ—»ğ—°ğ˜ğ—¶ğ—¼ğ—»ğ˜€:-
  =,(),[],->




*/
#include<iostream>
using namespace std;
class test
{
    int a,b,c;
    public:
    void setData(int a,int b,int c)
    {
        this->a=a;
        this->b=b;
        this->c=c;
    }
    void getData()
    {
        cout<<"a is"<<this->a<<endl;
        cout<<"b is"<<this->b<<endl;
        cout<<"c is"<<this->c<<endl;
    }
    void operator-()//unary minus Operator Overloading
    {
        this->a=-(this->a);
        this->b=-(this->b);
        this->c=-(this->c);
    }
    void operator!()//Overloading logical not Operator.
                    //Normally logical not returns 0 for every non-zero value and returns 1 for zero.
    {
        this->a=!(this->a);
        this->b=!(this->b);
        this->c=!(this->c);
    }
    test operator--()//pre decrement operator overloading
    {
        test obj;
        obj.a=(--(this->a));
        obj.b=(--(this->b));
        obj.c=(--(this->c));
        return obj;
    }
    test operator++()//pre increment operator overloading
    {
        test obj;
        obj.a=(++(this->a));
        obj.b=(++(this->b));
        obj.c=(++(this->c));
        return obj;
    }
    test operator--(int)//post decrement operator overloading
    {
        test obj;
        obj.a=((this->a)--);
        obj.b=((this->b)--);
        obj.c=((this->c)--);
        return obj;
    }
    test operator++(int)//post increment operator overloading
    {
        test obj;
        this->a=((this->a)++);
        this->b=((this->b)++);
        this->c=((this->c)++);
        return obj;
    }
};
int main()
{
    test t1;
    t1.setData(10,-32,-99);
    cout<<"original t1"<<endl;
    t1.getData();
    -t1;
    cout<<"negative of t1"<<endl;
    t1.getData();
    test t2;
    t2=++t1;//overloaded pre-increment
    cout<<"t1 values after pre-increment"<<endl;
    t1.getData();
    cout<<"t2 values"<<endl;
    t2.getData();
    test t3;
    t3=t1--;//overloaded post decrement
    cout<<"t3 values"<<endl;
    t3.getData();
    cout<<"t1 valules post decrement"<<endl;
    t1.getData();

}